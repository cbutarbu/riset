{"ast":null,"code":"// Generated by CoffeeScript 1.3.3\n(function () {\n  var events,\n      isEmpty,\n      sax,\n      __hasProp = {}.hasOwnProperty,\n      __extends = function (child, parent) {\n    for (var key in parent) {\n      if (__hasProp.call(parent, key)) child[key] = parent[key];\n    }\n\n    function ctor() {\n      this.constructor = child;\n    }\n\n    ctor.prototype = parent.prototype;\n    child.prototype = new ctor();\n    child.__super__ = parent.prototype;\n    return child;\n  },\n      __bind = function (fn, me) {\n    return function () {\n      return fn.apply(me, arguments);\n    };\n  };\n\n  sax = require('sax');\n  events = require('events');\n\n  isEmpty = function (thing) {\n    return typeof thing === \"object\" && thing != null && Object.keys(thing).length === 0;\n  };\n\n  exports.defaults = {\n    \"0.1\": {\n      explicitCharkey: false,\n      trim: true,\n      normalize: true,\n      attrkey: \"@\",\n      charkey: \"#\",\n      explicitArray: false,\n      ignoreAttrs: false,\n      mergeAttrs: false,\n      explicitRoot: false,\n      validator: null\n    },\n    \"0.2\": {\n      explicitCharkey: false,\n      trim: false,\n      normalize: false,\n      attrkey: \"$\",\n      charkey: \"_\",\n      explicitArray: true,\n      ignoreAttrs: false,\n      mergeAttrs: false,\n      explicitRoot: true,\n      validator: null\n    }\n  };\n\n  exports.ValidationError = function (_super) {\n    __extends(ValidationError, _super);\n\n    function ValidationError(message) {\n      this.message = message;\n    }\n\n    return ValidationError;\n  }(Error);\n\n  exports.Parser = function (_super) {\n    __extends(Parser, _super);\n\n    function Parser(opts) {\n      this.parseString = __bind(this.parseString, this);\n      this.reset = __bind(this.reset, this);\n\n      var key, value, _ref;\n\n      this.options = {};\n      _ref = exports.defaults[\"0.2\"];\n\n      for (key in _ref) {\n        if (!__hasProp.call(_ref, key)) continue;\n        value = _ref[key];\n        this.options[key] = value;\n      }\n\n      for (key in opts) {\n        if (!__hasProp.call(opts, key)) continue;\n        value = opts[key];\n        this.options[key] = value;\n      }\n\n      this.reset();\n    }\n\n    Parser.prototype.reset = function () {\n      var attrkey,\n          charkey,\n          err,\n          stack,\n          _this = this;\n\n      this.removeAllListeners();\n      this.saxParser = sax.parser(true, {\n        trim: false,\n        normalize: false\n      });\n      err = false;\n\n      this.saxParser.onerror = function (error) {\n        if (!err) {\n          err = true;\n          return _this.emit(\"error\", error);\n        }\n      };\n\n      this.EXPLICIT_CHARKEY = this.options.explicitCharkey;\n      this.resultObject = null;\n      stack = [];\n      attrkey = this.options.attrkey;\n      charkey = this.options.charkey;\n\n      this.saxParser.onopentag = function (node) {\n        var key, obj, _ref;\n\n        obj = {};\n        obj[charkey] = \"\";\n\n        if (!_this.options.ignoreAttrs) {\n          _ref = node.attributes;\n\n          for (key in _ref) {\n            if (!__hasProp.call(_ref, key)) continue;\n\n            if (!(attrkey in obj) && !_this.options.mergeAttrs) {\n              obj[attrkey] = {};\n            }\n\n            if (_this.options.mergeAttrs) {\n              obj[key] = node.attributes[key];\n            } else {\n              obj[attrkey][key] = node.attributes[key];\n            }\n          }\n        }\n\n        obj[\"#name\"] = node.name;\n        return stack.push(obj);\n      };\n\n      this.saxParser.onclosetag = function () {\n        var node, nodeName, obj, old, s, xpath;\n        obj = stack.pop();\n        nodeName = obj[\"#name\"];\n        delete obj[\"#name\"];\n        s = stack[stack.length - 1];\n\n        if (obj[charkey].match(/^\\s*$/)) {\n          delete obj[charkey];\n        } else {\n          if (_this.options.trim) {\n            obj[charkey] = obj[charkey].trim();\n          }\n\n          if (_this.options.normalize) {\n            obj[charkey] = obj[charkey].replace(/\\s{2,}/g, \" \").trim();\n          }\n\n          if (Object.keys(obj).length === 1 && charkey in obj && !_this.EXPLICIT_CHARKEY) {\n            obj = obj[charkey];\n          }\n        }\n\n        if (_this.options.emptyTag !== void 0 && isEmpty(obj)) {\n          obj = _this.options.emptyTag;\n        }\n\n        if (_this.options.validator != null) {\n          xpath = \"/\" + function () {\n            var _i, _len, _results;\n\n            _results = [];\n\n            for (_i = 0, _len = stack.length; _i < _len; _i++) {\n              node = stack[_i];\n\n              _results.push(node[\"#name\"]);\n            }\n\n            return _results;\n          }().concat(nodeName).join(\"/\");\n\n          obj = _this.options.validator(xpath, s && s[nodeName], obj);\n        }\n\n        if (stack.length > 0) {\n          if (!_this.options.explicitArray) {\n            if (!(nodeName in s)) {\n              return s[nodeName] = obj;\n            } else if (s[nodeName] instanceof Array) {\n              return s[nodeName].push(obj);\n            } else {\n              old = s[nodeName];\n              s[nodeName] = [old];\n              return s[nodeName].push(obj);\n            }\n          } else {\n            if (!(s[nodeName] instanceof Array)) {\n              s[nodeName] = [];\n            }\n\n            return s[nodeName].push(obj);\n          }\n        } else {\n          if (_this.options.explicitRoot) {\n            old = obj;\n            obj = {};\n            obj[nodeName] = old;\n          }\n\n          _this.resultObject = obj;\n          return _this.emit(\"end\", _this.resultObject);\n        }\n      };\n\n      return this.saxParser.ontext = this.saxParser.oncdata = function (text) {\n        var s;\n        s = stack[stack.length - 1];\n\n        if (s) {\n          return s[charkey] += text;\n        }\n      };\n    };\n\n    Parser.prototype.parseString = function (str, cb) {\n      if (cb != null && typeof cb === \"function\") {\n        this.on(\"end\", function (result) {\n          this.reset();\n          return cb(null, result);\n        });\n        this.on(\"error\", function (err) {\n          this.reset();\n          return cb(err);\n        });\n      }\n\n      if (str.toString().trim() === '') {\n        this.emit(\"end\", null);\n        return true;\n      }\n\n      try {\n        return this.saxParser.write(str.toString());\n      } catch (ex) {\n        if (ex instanceof exports.ValidationError) {\n          return this.emit(\"error\", ex.message);\n        } else {\n          throw ex;\n        }\n      }\n    };\n\n    return Parser;\n  }(events.EventEmitter);\n}).call(this);","map":null,"metadata":{},"sourceType":"script"}